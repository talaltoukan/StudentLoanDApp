import * as Web3 from "web3";
import { DebtOrder, IssuanceCommitment, TxData } from "../types";
import { ContractsAPI } from ".";
export declare const OrderAPIErrors: {
    EXPIRED: () => any;
    INVALID_UNDERWRITER_FEE: () => any;
    INVALID_RELAYER_FEE: () => any;
    INVALID_DEBTOR_FEE: () => any;
    INVALID_FEES: () => any;
    ORDER_CANCELLED: () => any;
    ORDER_ALREADY_CANCELLED: () => any;
    UNAUTHORIZED_ORDER_CANCELLATION: () => any;
    UNAUTHORIZED_ISSUANCE_CANCELLATION: () => any;
    CREDITOR_BALANCE_INSUFFICIENT: () => any;
    CREDITOR_ALLOWANCE_INSUFFICIENT: () => any;
    ISSUANCE_CANCELLED: () => any;
    ISSUANCE_ALREADY_CANCELLED: () => any;
    DEBT_ORDER_ALREADY_FILLED: () => any;
    INVALID_DEBTOR_SIGNATURE: () => any;
    INVALID_CREDITOR_SIGNATURE: () => any;
    INVALID_UNDERWRITER_SIGNATURE: () => any;
};
export declare class OrderAPI {
    private web3;
    private assert;
    private contracts;
    constructor(web3: Web3, contracts: ContractsAPI);
    /**
     * Asynchronously fills a signed debt order.
     *
     * If the order fills successfully, the creditor will be debited the
     * principal amount, the debtor will receive the principal, and the
     * underwriter and the relayer will receive their transaction fees
     * (if applicable).
     *
     * The debt order must be signed by all relevant parties and the associated
     * data must be valid in order for the order to be fulfilled.
     *
     * @param  debtOrder a valid, signed debt order.
     * @param  options   any params needed to modify the Ethereum transaction.
     * @return           the hash of the ethereum transaction that fulfilled the debt order.
     */
    fillAsync(debtOrder: DebtOrder.Instance, options?: TxData): Promise<string>;
    /**
     * Asynchronously cancel a debt order if it has yet to be fulfilled.
     *
     * @param  debtOrder the debt order to be canceled.
     * @param  options   any params needed to modify the Ethereum transaction.
     * @return           the hash of the resulting Ethereum transaction.
     */
    cancelOrderAsync(debtOrder: DebtOrder.Instance, options?: TxData): Promise<string>;
    /**
     * Given a complete debt order, asynchronously computes the issuanceHash
     * (alias of debtAgreementId) of the debt order.
     *
     * Note: If the kernelVersion or issuanceVersion are not specified, the
     * current DebtKernel and RepaymentRouter's addresses will be used
     * respectively.
     *
     * @param debtOrder Debt order for which we'd like to compute the issuance hash
     * @return The debt order's issuanceHash (alias of debtAgreementId).
     */
    getIssuanceHash(debtOrder: DebtOrder.Instance): Promise<string>;
    cancelIssuanceAsync(issuanceCommitment: IssuanceCommitment, transactionOptions: TxData): Promise<string>;
    private assertValidityInvariantsAsync(debtOrder, debtKernel, debtToken);
    private assertConsensualityInvariants(debtOrder, transactionOptions);
    private assertExternalBalanceAndAllowanceInvariantsAsync(debtOrder, tokenTransferProxy, transactionOptions);
    private getTxDefaultOptions();
}
