import { DebtOrder, TxData } from "../types";
import { DebtTokenContract, DebtKernelContract, TokenTransferProxyContract, ERC20Contract } from "../wrappers";
import { ContractsAPI } from "../apis";
export declare class OrderAssertions {
    private contracts;
    constructor(contracts: ContractsAPI);
    validDebtorFee(debtOrder: DebtOrder.Instance, errorMessage: string): void;
    validUnderwriterFee(debtOrder: DebtOrder.Instance, errorMessage: string): void;
    validRelayerFee(debtOrder: DebtOrder.Instance, errorMessage: string): void;
    validFees(debtOrder: DebtOrder.Instance, errorMessage: string): void;
    notExpired(debtOrder: DebtOrder.Instance, errorMessage: string): void;
    notAlreadyIssuedAsync(debtOrder: DebtOrder.Instance, debtToken: DebtTokenContract, errorMessage: string): Promise<void>;
    debtOrderNotCancelledAsync(debtOrder: DebtOrder.Instance, debtKernel: DebtKernelContract, errorMessage: string): Promise<void>;
    issuanceNotCancelledAsync(debtOrder: DebtOrder.Instance, debtKernel: DebtKernelContract, errorMessage: string): Promise<void>;
    senderAuthorizedToCancelOrder(debtOrder: DebtOrder.Instance, transactionOptions: TxData, errorMessage: string): void;
    senderAuthorizedToCancelIssuance(debtOrder: DebtOrder.Instance, transactionOptions: TxData, errorMessage: string): void;
    validDebtorSignature(debtOrder: DebtOrder.Instance, transactionOptions: TxData, errorMessage: string): Promise<void>;
    validCreditorSignature(debtOrder: DebtOrder.Instance, transactionOptions: TxData, errorMessage: string): Promise<void>;
    validUnderwriterSignature(debtOrder: DebtOrder.Instance, transactionOptions: TxData, errorMessage: string): Promise<void>;
    sufficientCreditorBalanceAsync(debtOrder: DebtOrder.Instance, principalToken: ERC20Contract, errorMessage: string): Promise<void>;
    sufficientCreditorAllowanceAsync(debtOrder: DebtOrder.Instance, principalToken: ERC20Contract, tokenTransferProxy: TokenTransferProxyContract, errorMessage: string): Promise<void>;
}
